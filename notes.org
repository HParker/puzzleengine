make BISON=/usr/local/opt/bison/bin/bison FLEX=/usr/local/opt/flex/bin/flex CC=/usr/local/Cellar/gcc/10.2.0/bin/gcc-10 && make check

TODO:
- for logging, errors and debugging I kinda want a struct like
Noun {
  int id,
  enum type,
  string name,
}

instead of passing around ids, we would pass nouns

- you can undo forever. stop it before it runs out of things to undo!
- should `ObjectGlyph` be ncurses renderer specific?
  seems unlikely we would need to show the character in any other context.
- validate object names used in rules exist or are `...`
- validate has background
- make sure all objects are in a layer
- maybe just objects with x,y
- sounds
- "levels must be rectangular" We don't have to do this, but can.
- There are some helpful errors we can add like direction in `late` rules will never match.
- When applying directions, the last rule that applies the direction always wins. This can be confusing and could give a warning. It might be hard to warn about because it has to be proved that the match is identical

- PS doesn't do this, but [ > One Two ] makes no sense and should probably error. Or apply only to the first object
- the direction handling in rules should move down a level. I think we can parse direction and legendId together and it will be cleaner/make more sense

- It is possible in PS to write late [ altplayer Teleport ] [ Teleport no altplayer ] -> [altplayer teleport] [Teleport player ]
  for some reason this does not apply forever. Replacing the second `[]` should match forever since adding `player` there does not prevent the match.
  in my PS you have to specify [ no playerType ] where `playerType = Player or AltPlayer`
  I think I am ok with this for now, but maybe I will find out why it works later.

3d api:
- transfer levels with `lift` and `lower`
- maybe specify 3d levels with,
#####
#.O.#
#OOO#
#.O.#
#####
-----
#####
#   #
# O #
#   #
#####


good rule debug:
        if (0 && debug() && aliasLegendContains(legendId, rt->objects[j].objId) == 1) {
          printf("RULE MATCH STATUS ('%s')\ncontains: %i\nlocation %i\ndirection: %i\n------\n",
                 objectName(rt->objects[j].objId),
                 aliasLegendContains(legendId, rt->objects[j].objId),
                 ((objectX == currentX && objectY == currentY) ||
                  (anyDistance == 1 && matchAtDistance(dir, currentX, currentY, objectX, objectY))),
                 matchesDirection(ruleDir, dir, directionMoving(rt, j))
                 );
        }
print object:
        printf("checking match identity '%s'\n------------\n", objectName(rt->objects[j].objId));
        printf("<OBJ live: %i (%i,%i) id: %i dir: %i>\n",
               rt->objects[j].deleted == 0,
               rt->objects[j].x,
               rt->objects[j].y,
               aliasLegendContains(legendId, rt->objects[j].objId),
               matchesDirection(ruleDir, dir, directionMoving(rt, j)) == 1);
